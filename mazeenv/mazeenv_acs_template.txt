//
// Modified from https://github.com/microsoft/MazeExplorer/blob/master/mazeexplorer/content/acs_template.txt
//

#include "zcommon.acs"

#define TARGET_ID_START 1000
#define GOAL_TID 999

int TARGET_ID_END = TARGET_ID_START;

global int 0:reward;
global int 1:goal_x;
global int 2:goal_y;
global int 3:goal_z;
global int 4:map_level;
global int 5:key_obj_idx;
global int 6:last_obj_picked;
global int 7:num_obj_spawn;
global int 8:player_spawn_ok;

int target_id_offset = 10000;
int target_id;
bool obj_exists[ $num_keys ];

int xmin = $xmin;
int ymin = $ymin;
int xmax = $xmax;
int ymax = $ymax;

int num_keys = $num_keys;
bool random_textures = $random_textures;
bool random_key_textures = $random_key_textures;
int num_key_textures[ $num_keys ] = $num_key_textures;
str key_textures[ $num_keys ][ $max_category_size ] = $key_textures;
int curr_key_textures[ $num_keys ];
int default_key_textures[ $num_keys ] = $default_key_textures;
int num_keys_used = $num_keys_used;
int keys_used[ $num_keys_used ] = $keys_used;

str floor_texture = "$floor_texture";
str ceiling_texture = "$ceiling_texture";
str wall_texture = "$wall_texture";

int SPAWN_LOC_ID = 0;


bool random_key_positions = $random_key_positions;
bool use_key_boxes = $use_key_boxes;
int num_boxes = $num_boxes;
int key_boxes_x[ $num_boxes ][2] = $key_boxes_x;
int key_boxes_y[ $num_boxes ][2] = $key_boxes_y;

bool shuffle_obj_pos = $shuffle_obj_pos;
int abs_keys_spawn_x[ $num_keys ] = { $abs_keys_spawn_x };
int abs_keys_spawn_y[ $num_keys ] = { $abs_keys_spawn_y };

bool random_spawn = $random_spawn;
int abs_spawn_x = $abs_spawn_x;
int abs_spawn_y = $abs_spawn_y;

bool random_spawn_angle = $random_spawn_angle;
int spawn_angle = $spawn_angle;

str texturesToRandomize[ $num_textures ] = $textures

int rand_queue_key[ $num_keys ];
int rand_queue_box[ $num_boxes ];
int queue_len;

str debug_print = "";

function void addDebugPrint(str s_in)
{
    debug_print = StrParam(s: debug_print, s: s_in);
}

function void debugPrint(void)
{
    Print(s: debug_print);
}

function str GetRandomTexture(void)
{
    return texturesToRandomize[Random(0, $num_textures - 1 )];
}

function void RandomTextures(void)
{
    ReplaceTextures("CEIL5_2", GetRandomTexture());
    ReplaceTextures("CEIL5_1", GetRandomTexture());
    ReplaceTextures("STONE2", GetRandomTexture());
    Light_ChangeToValue(0, Random(150, 255));
}

function void SpawnKeyAbsPos(int pos_idx, int obj_idx)
{
    str key_obj_texture = key_textures[obj_idx][curr_key_textures[obj_idx]];
    bool is_target = (obj_idx == key_obj_idx);
    if (is_target)
    {
        target_id = target_id_offset + obj_idx;
        num_obj_spawn += Spawn(key_obj_texture, abs_keys_spawn_x[pos_idx],
            abs_keys_spawn_y[pos_idx], 0.0, target_id, 128);
        SetThingSpecial(target_id, ACS_ExecuteAlways, 5);
    }
    else
    {
        num_obj_spawn += Spawn(key_obj_texture, abs_keys_spawn_x[pos_idx],
            abs_keys_spawn_y[pos_idx], 0.0, target_id_offset + obj_idx, 128);
        SetThingSpecial(target_id_offset + obj_idx, ACS_ExecuteAlways, 6);
    }
}

function void SpawnKeyRandom(int obj_idx, int box_idx, str obj_texture)
{
    bool is_target = (obj_idx == key_obj_idx);
    int _xmin, _xmax, _ymin, _ymax;

    if (box_idx == -1)  // don't use boxes, sample pos within entire map
    {
        _xmin = xmin;
        _xmax = xmax;
        _ymin = ymin;
        _ymax = ymax;
    }
    else {  // use boxes, sample pos within given box
        _xmin = key_boxes_x[box_idx][0];
        _xmax = key_boxes_x[box_idx][1];
        _ymin = key_boxes_y[box_idx][0];
        _ymax = key_boxes_y[box_idx][1];
    }

    if (is_target)
    {
        target_id = target_id_offset + obj_idx;
        num_obj_spawn += SpawnForced(obj_texture, Random(_xmin, _xmax),
            Random(_ymin, _ymax), 0.0, target_id, 128);
        SetThingSpecial(target_id, ACS_ExecuteAlways, 5);
    }
    else
    {
        num_obj_spawn += SpawnForced(obj_texture, Random(_xmin, _xmax),
            Random(_ymin, _ymax), 0.0, target_id_offset + obj_idx, 128);
        SetThingSpecial(target_id_offset + obj_idx, ACS_ExecuteAlways, 6);
    }
}

function void init_queue(bool is_for_box)
{
    int i;
    if (is_for_box)
    {
        queue_len = num_boxes;
        for (i = 0; i < queue_len; i++)
        {
            rand_queue_box[i] = i;
        }
    }
    else
    {
        queue_len = num_keys;
        for (i = 0; i < queue_len; i++)
        {
            rand_queue_key[i] = i;
        }
    }
}

function int sample_wo_repl(bool is_for_box)
{
    int idx = Random(0, queue_len - 1);
    int ret, i;

    if (is_for_box)
    {
        ret = rand_queue_box[idx];
        for (i = idx + 1; i < queue_len; i++)
        {
            rand_queue_box[i - 1] = rand_queue_box[i];
        }
    }
    else
    {
        ret = rand_queue_key[idx];
        for (i = idx + 1; i < queue_len; i++)
        {
            rand_queue_key[i - 1] = rand_queue_key[i];
        }
    }
    queue_len -= 1;

    return ret;
}

script 1 OPEN
{
}

script 2 ENTER
{

    map_level = GetLevelInfo (LEVELINFO_LEVELNUM);

    // determine which object category will be the target
    key_obj_idx = keys_used[Random(0, num_keys_used - 1)];

    // reset number of objects spawned
    num_obj_spawn = 0;

    // select key obj textures
    if (random_key_textures)
    {
        for (int i = 0; i < num_keys; i++)
        {
            curr_key_textures[i] = Random(0, num_key_textures[i] - 1);
        }
    }
    else
    {
        for (i = 0; i < num_keys; i++)
        {
            curr_key_textures[i] = default_key_textures[i];
        }
    }

    // set key positions
    if (random_key_positions)
    {
        if (use_key_boxes && shuffle_obj_pos)
        {
            init_queue(1);
            for (i = 0; i < num_keys; i++)
            {
                SpawnKeyRandom(i, sample_wo_repl(1), key_textures[i][curr_key_textures[i]]);
            }
        }
        else if (use_key_boxes)
        {
            for (i = 0; i < num_keys; i++)
            {
                SpawnKeyRandom(i, i, key_textures[i][curr_key_textures[i]]);
            }
        }
        else
        {
            for (i = 0; i < num_keys; i++)
            {
                SpawnKeyRandom(i, -1, key_textures[i][curr_key_textures[i]]);
            }
        }
    }
    else if (shuffle_obj_pos)   // fixed position, but random objs in given positions
    {
        init_queue(0);
        for (i = 0; i < num_keys; i++)
        {
            SpawnKeyAbsPos(i, sample_wo_repl(0));
        }
    }
    else  // fixed position, fixed objs
    {
        for (i = 0; i < num_keys; i++)
        {
            SpawnKeyAbsPos(i, i);
        }
    }
    
    reward = 0.0;

    // set textures
    if (random_textures)
    {
        RandomTextures();
    }
    else
    {
        ReplaceTextures("CEIL5_2", floor_texture);
        ReplaceTextures("CEIL5_1", ceiling_texture);
        ReplaceTextures("STONE2", wall_texture);
    }

    // set player's position at spawn
    if (random_spawn)
    {
        // spawn in random position
        while(!SetActorPosition(0, random(xmin, xmax), random(ymin, ymax), 0.0, 0));
        player_spawn_ok = 1;
    }
    else
    {
        // use absolute spawn position
        player_spawn_ok = SetActorPosition(0, abs_spawn_x, abs_spawn_y, 0.0, 0);
    }

    // set player's view angle at spawn
    if (random_spawn_angle)
    {
        SetActorAngle(0, random(0.0, 1.0));
    }
    else
    {
        SetActorAngle(0, spawn_angle);
    }

    for (i = 0; i < num_keys; i++)
    {
        obj_exists[i] = True;
    }
    last_obj_picked = -1;

    // debugPrint(); // DEBUG
}

script 5 (void)
{
    for (int i = 0; i < num_keys; i++)
    {
        if (obj_exists[i] && (!IsTIDUsed(target_id_offset + i)))
        {
            last_obj_picked = i;
            obj_exists[i] = False;
            break;
        }
    }
    Exit_Normal(0);
    restart;
}

script 6 (void)
{
    for (int i = 0; i < num_keys; i++)
    {
        if (obj_exists[i] && (!IsTIDUsed(target_id_offset + i)))
        {
            last_obj_picked = i;
            obj_exists[i] = False;
            break;
        }
    }
}
